"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const minimatch_1 = __importDefault(require("minimatch"));
const src = 'package.json';
const config = { zeroConfig: true };
const MISSING_BUILD_SCRIPT_ERROR = {
    code: 'missing_build_script',
    message: 'Your `package.json` file is missing a `build` property inside the `script` property.' +
        '\nMore details: https://zeit.co/docs/v2/advanced/platform/frequently-asked-questions#missing-build-script',
};
// Static builders are special cased in `@now/static-build`
function getBuilders() {
    return new Map([
        ['next', { src, use: '@now/next', config }],
    ]);
}
// Must be a function to ensure that the returned
// object won't be a reference
function getApiBuilders() {
    return [
        { src: 'api/**/*.js', use: '@now/node', config },
        { src: 'api/**/*.ts', use: '@now/node', config },
        { src: 'api/**/*.go', use: '@now/go', config },
        { src: 'api/**/*.py', use: '@now/python', config },
        { src: 'api/**/*.rb', use: '@now/ruby', config },
    ];
}
function hasPublicDirectory(files) {
    return files.some(name => name.startsWith('public/'));
}
function hasBuildScript(pkg) {
    const { scripts = {} } = pkg || {};
    return Boolean(scripts && scripts['build']);
}
async function detectBuilder(pkg) {
    for (const [dependency, builder] of getBuilders()) {
        const deps = Object.assign({}, pkg.dependencies, pkg.devDependencies);
        // Return the builder when a dependency matches
        if (deps[dependency]) {
            return builder;
        }
    }
    // By default we'll choose the `static-build` builder
    return { src, use: '@now/static-build', config };
}
// Files that match a specific pattern will get ignored
function ignoreApiFilter(file) {
    if (file.includes('/.')) {
        return false;
    }
    if (file.includes('/_')) {
        return false;
    }
    if (file.endsWith('.d.ts')) {
        return false;
    }
    // If the file does not match any builder we also
    // don't want to create a route e.g. `package.json`
    if (getApiBuilders().every(({ src }) => !minimatch_1.default(file, src))) {
        return false;
    }
    return true;
}
exports.ignoreApiFilter = ignoreApiFilter;
// We need to sort the file paths by alphabet to make
// sure the routes stay in the same order e.g. for deduping
function sortFiles(fileA, fileB) {
    return fileA.localeCompare(fileB);
}
exports.sortFiles = sortFiles;
async function detectApiBuilders(files) {
    const builds = files
        .sort(sortFiles)
        .filter(ignoreApiFilter)
        .map(file => {
        const result = getApiBuilders().find(({ src }) => minimatch_1.default(file, src));
        return result ? { ...result, src: file } : null;
    });
    const finishedBuilds = builds.filter(Boolean);
    return finishedBuilds;
}
// When zero config is used we can call this function
// to determine what builders to use
async function detectBuilders(files, pkg, options) {
    const errors = [];
    // Detect all builders for the `api` directory before anything else
    let builders = await detectApiBuilders(files);
    if (pkg && hasBuildScript(pkg)) {
        builders.push(await detectBuilder(pkg));
    }
    else {
        if (pkg && builders.length === 0) {
            // We only show this error when there are no api builders
            // since the dependencies of the pkg could be used for those
            errors.push(MISSING_BUILD_SCRIPT_ERROR);
            return { errors, builders: null };
        }
        // We allow a `public` directory
        // when there are no build steps
        if (hasPublicDirectory(files)) {
            builders.push({
                use: '@now/static',
                src: 'public/**/*',
                config,
            });
        }
        else if (builders.length > 0) {
            // We can't use pattern matching, since `!(api)` and `!(api)/**/*`
            // won't give the correct results
            builders.push(...files
                .filter(name => !name.startsWith('api/'))
                .filter(name => !(name === 'package.json'))
                .map(name => ({
                use: '@now/static',
                src: name,
                config,
            })));
        }
    }
    // Change the tag for the builders
    if (builders && builders.length) {
        const tag = options && options.tag;
        if (tag) {
            builders = builders.map((originBuilder) => {
                // Copy builder to make sure it is not a reference
                const builder = { ...originBuilder };
                // @now/static has no canary builder
                if (builder.use !== '@now/static') {
                    builder.use = `${builder.use}@${tag}`;
                }
                return builder;
            });
        }
    }
    return {
        builders: builders.length ? builders : null,
        errors: errors.length ? errors : null,
    };
}
exports.detectBuilders = detectBuilders;
