"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const util_1 = require("util");
const node_version_1 = require("./node-version");
function spawnAsync(command, args, cwd, opts = {}) {
    return new Promise((resolve, reject) => {
        const stderrLogs = [];
        opts = { stdio: 'inherit', cwd, ...opts };
        const child = cross_spawn_1.default(command, args, opts);
        if (opts.stdio === 'pipe' && child.stderr) {
            child.stderr.on('data', data => stderrLogs.push(data));
        }
        child.on('error', reject);
        child.on('close', (code, signal) => {
            if (code === 0) {
                return resolve();
            }
            const errorLogs = stderrLogs.map(line => line.toString()).join('');
            if (opts.stdio !== 'inherit') {
                reject(new Error(`Exited with ${code || signal}\n${errorLogs}`));
            }
            else {
                reject(new Error(`Exited with ${code || signal}`));
            }
        });
    });
}
async function chmodPlusX(fsPath) {
    const s = await fs_extra_1.default.stat(fsPath);
    const newMode = s.mode | 64 | 8 | 1; // eslint-disable-line no-bitwise
    if (s.mode === newMode)
        return;
    const base8 = newMode.toString(8).slice(-3);
    await fs_extra_1.default.chmod(fsPath, base8);
}
async function runShellScript(fsPath, args = [], spawnOpts) {
    assert_1.default(path_1.default.isAbsolute(fsPath));
    const destPath = path_1.default.dirname(fsPath);
    await chmodPlusX(fsPath);
    await spawnAsync(`./${path_1.default.basename(fsPath)}`, args, destPath, spawnOpts);
    return true;
}
exports.runShellScript = runShellScript;
function getSpawnOptions(meta, nodeVersion) {
    const opts = {
        env: { ...process.env },
    };
    if (!meta.isDev) {
        opts.env.PATH = `/node${nodeVersion.major}/bin:${opts.env.PATH}`;
    }
    return opts;
}
exports.getSpawnOptions = getSpawnOptions;
async function getNodeVersion(destPath, minNodeVersion, config) {
    const { packageJson } = await scanParentDirs(destPath, true);
    let range;
    let silent = false;
    if (packageJson && packageJson.engines && packageJson.engines.node) {
        range = packageJson.engines.node;
    }
    else if (minNodeVersion) {
        range = minNodeVersion;
        silent = true;
    }
    else if (config && config.zeroConfig) {
        // Use latest node version zero config detected
        range = '10.x';
        silent = true;
    }
    return node_version_1.getSupportedNodeVersion(range, silent);
}
exports.getNodeVersion = getNodeVersion;
async function scanParentDirs(destPath, readPackageJson = false) {
    assert_1.default(path_1.default.isAbsolute(destPath));
    let hasPackageLockJson = false;
    let packageJson;
    let currentDestPath = destPath;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const packageJsonPath = path_1.default.join(currentDestPath, 'package.json');
        // eslint-disable-next-line no-await-in-loop
        if (await fs_extra_1.default.pathExists(packageJsonPath)) {
            // eslint-disable-next-line no-await-in-loop
            if (readPackageJson) {
                packageJson = JSON.parse(await fs_extra_1.default.readFile(packageJsonPath, 'utf8'));
            }
            // eslint-disable-next-line no-await-in-loop
            hasPackageLockJson = await fs_extra_1.default.pathExists(path_1.default.join(currentDestPath, 'package-lock.json'));
            break;
        }
        const newDestPath = path_1.default.dirname(currentDestPath);
        if (currentDestPath === newDestPath)
            break;
        currentDestPath = newDestPath;
    }
    return { hasPackageLockJson, packageJson };
}
async function runNpmInstall(destPath, args = [], spawnOpts) {
    assert_1.default(path_1.default.isAbsolute(destPath));
    let commandArgs = args;
    console.log(`installing to ${destPath}`);
    const { hasPackageLockJson } = await scanParentDirs(destPath);
    const opts = spawnOpts || { env: process.env };
    if (hasPackageLockJson) {
        commandArgs = args.filter(a => a !== '--prefer-offline');
        await spawnAsync('npm', commandArgs.concat(['install', '--unsafe-perm']), destPath, opts);
    }
    else {
        await spawnAsync('yarn', commandArgs.concat(['--ignore-engines', '--cwd', destPath]), destPath, opts);
    }
}
exports.runNpmInstall = runNpmInstall;
async function runPackageJsonScript(destPath, scriptName, opts) {
    assert_1.default(path_1.default.isAbsolute(destPath));
    const { packageJson, hasPackageLockJson } = await scanParentDirs(destPath, true);
    const hasScript = Boolean(packageJson &&
        packageJson.scripts &&
        scriptName &&
        packageJson.scripts[scriptName]);
    if (!hasScript)
        return false;
    if (hasPackageLockJson) {
        console.log(`running "npm run ${scriptName}"`);
        await spawnAsync('npm', ['run', scriptName], destPath, opts);
    }
    else {
        console.log(`running "yarn run ${scriptName}"`);
        await spawnAsync('yarn', ['--cwd', destPath, 'run', scriptName], destPath, opts);
    }
    return true;
}
exports.runPackageJsonScript = runPackageJsonScript;
/**
 * @deprecate installDependencies() is deprecated.
 * Please use runNpmInstall() instead.
 */
exports.installDependencies = util_1.deprecate(runNpmInstall, 'installDependencies() is deprecated. Please use runNpmInstall() instead.');
